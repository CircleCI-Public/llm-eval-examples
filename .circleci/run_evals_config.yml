version: 2.1

orbs:
  ai-evals:
    # This code is licensed from CircleCI to the user under the MIT license.
    # See here for details: https://circleci.com/developer/orbs/licensing
    version: 2.1
    description: |
      Orb for running AI LLM app evals. Send any feedback at ai-feedback@circleci.com
    display:
      home_url: https://github.com/CircleCI-Public/ai-evals-orb/wiki
      source_url: https://github.com/CircleCI-Public/ai-evals-orb
    commands:
      eval:
        description: This command runs an evaluation for the specified platform and saves results to specified location.
        parameters:
          braintrust_experiment_name:
            default: ""
            description: Braintrust experiment name
            type: string
          circle_pipeline_id:
            description: CircleCI Pipeline ID
            type: string
          cmd:
            description: command to execute
            type: string
          eval_platform:
            default: braintrust
            description: evaluation platform
            enum:
              - braintrust
              - langsmith
            type: string
          evals_result_location:
            default: ./results
            description: evaluation result location
            type: string
          langsmith_endpoint:
            default: ""
            description: Langsmith endpoint
            type: string
          langsmith_experiment_name:
            default: ""
            description: Langsmith experiment name
            type: string
        steps:
          - run:
              command: |
                #!/bin/sh

                # Hi! Based off the slack-orb-go main.sh. If you plan to have osx & windows
                # support go look at that file and bring it back in.

                # Determine the http client to use
                # Returns 1 if no HTTP client is found
                determine_http_client() {
                    if command -v curl >/dev/null 2>&1; then
                        HTTP_CLIENT=curl
                    elif command -v wget >/dev/null 2>&1; then
                        HTTP_CLIENT=wget
                    else
                        return 1
                    fi
                }

                # Download a binary file
                # $1: The path to save the file to
                # $2: The URL to download the file from
                # $3: The HTTP client to use (curl or wget)
                download_binary() {
                    if [ "$3" = "curl" ]; then
                        set -x
                        curl --fail --retry 3 -L -o "$1" "$2"
                        set +x
                    elif [ "$3" = "wget" ]; then
                        set -x
                        wget --tries=3 --timeout=10 --quiet -O "$1" "$2"
                        set +x
                    else
                        return 1
                    fi
                }

                detect_os() {
                    detected_platform="$(uname -s | tr '[:upper:]' '[:lower:]')"
                    case "$detected_platform" in
                    linux*) PLATFORM=linux ;;
                    # darwin*) PLATFORM=darwin ;;
                    # msys* | cygwin*) PLATFORM=windows ;;
                    *) return 1 ;;
                    esac
                }

                detect_arch() {
                    detected_arch="$(uname -m)"
                    case "$detected_arch" in
                    x86_64 | amd64) ARCH=amd64 ;;
                    i386 | i486 | i586 | i686) ARCH=386 ;;
                    arm64 | aarch64) ARCH=arm64 ;;
                    arm*) ARCH=arm ;;
                    *) return 1 ;;
                    esac
                }

                # Confirm we have unzip available
                # Returns 1 if unzip not found
                detect_unzip() {
                    if command -v unzip >/dev/null 2>&1; then
                        return 0
                    fi
                    return 1
                }

                # Print a warning message
                # $1: The warning message to print
                print_warn() {
                    yellow="\033[1;33m"
                    normal="\033[0m"
                    printf "${yellow}%s${normal}\n" "$1"
                }

                # Print a success message
                # $1: The success message to print
                print_success() {
                    green="\033[0;32m"
                    normal="\033[0m"
                    printf "${green}%s${normal}\n" "$1"
                }

                # Print an error message
                # $1: The error message to print
                print_error() {
                    red="\033[0;31m"
                    normal="\033[0m"
                    printf "${red}%s${normal}\n" "$1"
                }

                print_warn "This is an experimental version of the AI Evals orb."
                print_warn "Thank you for trying it out and please provide feedback to us at https://github.com/CircleCI-Public/ai-evals-orb/issues"

                if ! detect_os; then
                    print_error "Unsupported operating system: $(uname -s)."
                    exit 1
                fi
                printf '%s\n' "Operating system: $PLATFORM."

                if ! detect_arch; then
                    print_error "Unsupported architecture: $(uname -m)."
                    exit 1
                fi
                printf '%s\n' "Architecture: $ARCH."

                if ! detect_unzip; then
                    print_error "Unzip is required to download the $EVAL_PLATFORM AI Evals Orb binary."
                    exit 1
                fi

                base_dir="$(printf "%s" "$CIRCLE_WORKING_DIRECTORY" | sed "s|~|$HOME|")"
                orb_bin_dir="${base_dir}/.circleci/orbs/circleci/ai-evals/${PLATFORM}/${ARCH}"
                org="circleci"
                repo_name="cci-$EVAL_PLATFORM-eval"
                # binary="${orb_bin_dir}/${repo_name}"
                # TODO: Make the version configurable via parameter
                # Don't forget the v!
                case $EVAL_PLATFORM in
                    "braintrust")
                    binary_version="v0.0.3"
                    ;;
                    "langsmith")
                    binary_version="v0.0.3"
                    ;;
                    *)
                    echo "Unknown platform: $EVAL_PLATFORM" >&2
                    exit 1
                    ;;
                esac
                basic_name="cci-$EVAL_PLATFORM-eval"
                binary_name="${basic_name}-${binary_version}-${PLATFORM}-${ARCH}"
                binary_zip="${orb_bin_dir}/${binary_name}.zip"
                # Where to move the binary
                path_destination="$HOME/bin"
                # Slack orb seems to put this outside the script as a parameter
                # https://github.com/CircleCI-Public/slack-orb-go/blob/8c4e86c9a787c240138244610aada066059b5b46/src/commands/notify.yml#L80
                # TODO: keep support for this? Or will people not bother? They would have to do to the packagecloud URL and find it
                # when we parametize the version, we should support this as well
                input_sha256=""

                if [ ! -f "$binary_zip" ]; then
                    mkdir -p "$orb_bin_dir"
                    if ! determine_http_client; then
                        printf '%s\n' "cURL or wget is required to download the required binary."
                        printf '%s\n' "Please install cURL or wget and try again."
                        exit 1
                    fi
                    printf '%s\n' "HTTP client: $HTTP_CLIENT."
                    binary_url="https://packagecloud.io/${org}/${repo_name}/packages/anyfile/${binary_name}.zip/download?distro_version_id=230"
                    printf '%s\n' "Release URL: $binary_url."

                    if ! download_binary "$binary_zip" "$binary_url" "$HTTP_CLIENT"; then
                        printf '%s\n' "Failed to download $repo_name binary from Packagecloud."
                        exit 1
                    fi

                    printf '%s\n' "Downloaded $repo_name zip to $orb_bin_dir"
                else
                    printf '%s\n' "Skipping zip download since it already exists at $binary_zip."
                fi

                # Validate binary
                ## This validates, even if the binary already existed before.
                ## This can help with cache integrity but was also a convenience for testing where the binary will never be downloaded.
                if [ -n "$input_sha256" ]; then
                    actual_sha256=""
                    actual_sha256=$(sha256sum "$binary_zip" | cut -d' ' -f1)

                    if [ "$actual_sha256" != "$input_sha256" ]; then
                        print_error "SHA256 checksum does not match. Expected $input_sha256 but got $actual_sha256"
                        exit 1
                    else
                        print_success "SHA256 checksum matches. Binary is valid."
                    fi
                else
                    print_warn "SHA256 checksum not provided. Skipping validation."
                fi

                # Unzip binary
                # Please someone explain this to me - only works if I UNZIP to the $orb_bin_dir
                # Can't unzip to any other dest. then it fails. bad. wtf. If you can explain it, please let me know! Really.
                printf '%s\n' "Unzip ${binary_zip}..."
                if ! unzip -q "${binary_zip}" -d "$orb_bin_dir"; then
                    print_error "Failed to unzip $binary_zip."
                    exit 1
                fi

                printf '%s\n' "Making ${orb_bin_dir}/${binary_name} binary executable..."
                if ! chmod +x "${orb_bin_dir}/${binary_name}"; then
                    print_error "Failed to make ${orb_bin_dir}/${binary_name} binary executable."
                    exit 1
                fi

                printf '%s\n' "Moving $binary_name to PATH and renaming to ${basic_name}..."
                mkdir -p "$path_destination"
                echo 'export PATH=${path_destination}:"$PATH"' >> "$BASH_ENV"
                source "$BASH_ENV"
                if ! mv "$orb_bin_dir/$binary_name" "${path_destination}/${basic_name}"; then
                    print_error "Failed to move $orb_bin_dir/$binary_name binary executable."
                    exit 1
                fi

                print_success "Successfully installed $basic_name."
                exit 0
              environment:
                EVAL_PLATFORM: << parameters.eval_platform >>
              name: Download << parameters.eval_platform >> eval binary
          - run:
              command: |
                cci-<< parameters.eval_platform >>-eval << parameters.cmd >>
              environment:
                BRAINTRUST_EXPERIMENT_NAME: << parameters.braintrust_experiment_name >>
                CCI_LANGCHAIN_EXPERIMENT_NAME: << parameters.langsmith_experiment_name >>
                CIRCLE_PIPELINE_ID: << parameters.circle_pipeline_id >>
                EVAL_PLATFORM: << parameters.eval_platform >>
                EVALS_RESULT_LOCATION: << parameters.evals_result_location >>
                LANGCHAIN_ENDPOINT: << parameters.langsmith_endpoint >>
              name: Run evaluation
          - store_artifacts:
              path: << parameters.evals_result_location >>

# PIPELINE PARAMETERS
parameters:
  run-braintrust-evals:
    type: boolean
    default: false
  run-langsmith-evals:
    type: boolean
    default: false

# EXECUTORS
executors:
  python:
    docker:
      - image: python:3.11

# WORKFLOWS
workflows:
  braintrust-evals:
    when: << pipeline.parameters.run-braintrust-evals >>
    jobs:
      - run-braintrust-evals:
          context:
            - ai-ai-evals-orb-examples # Replace this with your context name
  langsmith-evals:
    when: << pipeline.parameters.run-langsmith-evals >>
    jobs:
      - run-langsmith-evals:
          context:
            - ai-ai-evals-orb-examples # Replace this with your context name

# JOBS
jobs:
  run-braintrust-evals:
    executor: python
    steps:
      - checkout
      # - run:
      #     name: install dependencies
      #     command: |
      #       pip install braintrust
      #       pip install -r ./braintrust/requirements.txt
      - ai-evals/eval:
          circle_pipeline_id: << pipeline.id >>
          eval_platform: braintrust
          cmd: braintrust eval braintrust/eval_tutorial.py

  run-langsmith-evals:
    executor: python
    steps:
      - checkout
      - run:
          name: install dependencies
          command: |
            pip install -r ./langsmith/requirements.txt
      - ai-evals/eval:
          circle_pipeline_id: << pipeline.id >>
          cmd: python3 langsmith/eval.py
          eval_platform: langsmith
